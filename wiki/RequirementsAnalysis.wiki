#summary One-sentence summary of this page.
#labels Phase-Requirements

= Introduction =

This page describes the use cases of gcov to identify requriments needed to integrate gcov in the eclipse cdt project.


= Details =

The following is from the gcc documentation in [http://www.mingw.org/ mingw] 4.4.0:

----

==-fprofile-arcs==
Add code so that program flow "arcs" are instrumented.  During execution the program records how many times each branch and call is executed and how many times it is taken or returns.  When the compiled program exits it saves this data to a file called `AUXNAME.gcda` for each source file.  The data may be used for profile-directed optimizations (`-fbranch-probabilities`), or for test coverage analysis (`-ftest-coverage`).  Each object file's AUXNAME is generated from the name of the output file, if explicitly specified and it is not the final executable, otherwise it is the basename of the source file.  In both cases any suffix is removed (e.g. `foo.gcda` for input file 
`dir/foo.c`, or `dir/foo.gcda` for output file specified as `-o dir/foo.o`). `*`Note Cross-profiling::.

==--coverage==
This option is used to compile and link code instrumented for coverage analysis.  The option is a synonym for `-fprofile-arcs` `-ftest-coverage` (when compiling) and `-lgcov` (when linking). See the documentation for those options for more details.

  * Compile the source files with `-fprofile-arcs` plus optimization and code generation options.  For test coverage analysis, use the additional `-ftest-coverage` option.  You do not need to profile every source file in a program.

  * Link your object files with `-lgcov` or `-fprofile-arcs` (the latter implies the former).

  * Run the program on a representative workload to generate the arc profile information.  This may be repeated any number of times.  You can run concurrent instances of your program, and provided that the file system supports locking, the data files will be correctly updated.  Also `fork` calls are detected and correctly handled (double counting will not happen).

  * For profile-directed optimizations, compile the source files again with the same optimization and code generation options plus `-fbranch-probabilities` (`*`note Options that Control Optimization: Optimize Options.).

  * For test coverage analysis, use `gcov` to produce human readable information from the `.gcno` and `.gcda` files. Refer to the `gcov` documentation for further information.


With `-fprofile-arcs`, for each function of your program GCC creates a program flow graph, then finds a spanning tree for the graph.  Only arcs that are not on the spanning tree have to be instrumented: the compiler adds code to count the number of times that these arcs are executed.  When an arc is the only exit or only entrance to a block, the instrumentation code can be added to the block; otherwise, a new basic block must be created to hold the instrumentation code.

==-ftest-coverage==
Produce a notes file that the `gcov` code-coverage utility (`*`note `gcov`--a Test Coverage Program: Gcov.) can use to show program coverage.  Each source file's note file is called `AUXNAME.gcno`. Refer to the `-fprofile-arcs` option above for a description of AUXNAME and instructions on how to generate test coverage data. Coverage data will match the source files more closely, if you do not optimize.